<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>温故而知新（巩固js基础第二篇）</title>
    <url>/2024/05/20/base-two/</url>
    <content><![CDATA[<h2 id="判断：if与三元"><a href="#判断：if与三元" class="headerlink" title="判断：if与三元"></a>判断：if与三元</h2><p>在第一篇讲到了各种运算符，这里的<code>三元运算符</code>不同于算术运算上，所以没有写在同一篇。</p>
<h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h3><p>常见的判断语句为<code>if else</code>，<code>if(...)</code> 语句计算括号里的条件表达式，如果计算结果是 <code>true</code>，就会执行对应的代码块。栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let test = true</span><br><span class="line">if(test) &#123;</span><br><span class="line">    alert(&#x27;进来了！&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">// 当代码块只有一条语句的时候，那么可以简写成：</span><br><span class="line">if(test) alert(&#x27;进来了！&#x27;);</span><br></pre></td></tr></table></figure>
<p><code>if</code> 语句有时会包含一个可选的 “else” 块。如果判断条件不成立，就会执行它内部的代码。栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当有else就不支持简写</span><br><span class="line">let test = true</span><br><span class="line">if(test) &#123;</span><br><span class="line">    alert(&#x27;进来了！&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;进了另外个门&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有时我们需要测试一个条件的几个变体。我们可以通过使用 <code>else if</code> 子句实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let test = true</span><br><span class="line">if(test) &#123;</span><br><span class="line">    alert(&#x27;进来了！&#x27;);</span><br><span class="line">&#125; else if &#123;</span><br><span class="line">    alert(&#x27;进了第二扇门&#x27;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    alert(&#x27;进了第三扇门&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码块都是从上到下，严格按照js的同步进行，先判断<code>if</code>是否为<code>true</code>，如果不是才会进行下一个语句判断，依次往下。当然可以有更多的 <code>else if</code> 块。结尾的 <code>else</code> 是可选的。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><code>if (…)</code> 语句会计算圆括号内的表达式，并将计算结果转换为布尔型</p>
<ul>
<li>  数字 <code>0</code>、空字符串 <code>&quot;&quot;</code>、<code>null</code>、<code>undefined</code> 和 <code>NaN</code> 都会被转换成 <code>false</code>。因为它们被称为“假值（falsy）”值。</li>
<li>  其他值被转换为 <code>true</code>，所以它们被称为“真值（truthy）”。<h3 id="三元运算符（条件运算符）‘-’"><a href="#三元运算符（条件运算符）‘-’" class="headerlink" title="三元运算符（条件运算符）‘?’"></a>三元运算符（条件运算符）‘?’</h3>我们需要根据一个条件去赋值一个变量就会想到使用刚刚才讲到的<code>if else</code>，但又感觉只是赋个值写代码块没必要。所谓的三元运算符让我们可以更简短地达到目的。之所以被称为“三元”是因为该运算符中有三个操作数。实际上它是 JavaScript 中唯一一个有这么多操作数的运算符。如何使用？栗子：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let result = condition ? value1 : value2;</span><br><span class="line">// 计算条件结果，如果结果为真，则返回 `value1`，否则返回 `value2`。</span><br></pre></td></tr></table></figure>
<p>当如果三元运算符用来判断返回<code>boolean</code>的话，可以不需要用到三元运算符。栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let result = age &gt; 18 ? true : false; </span><br><span class="line">// 与</span><br><span class="line">let result = age &gt; 18</span><br><span class="line">// 是一样的</span><br></pre></td></tr></table></figure>
<p>还可以嵌套多个三元运算符，但只可以返回一个取决于多个条件的值。栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let message = (age &lt; 3) ? &#x27;我不到三岁&#x27; : (age &lt; 18) </span><br><span class="line">?&#x27;我不到18岁&#x27; : (age &lt; 100) </span><br><span class="line">?&#x27;我不到100岁&#x27; : &#x27;剩下就是我的岁数&#x27;;</span><br></pre></td></tr></table></figure>
<p>可能很难一下子看出发生了什么。就很影响了可读性。</p>
<ol>
<li> 第一个问号检查 <code>age &lt; 3</code>。</li>
<li> 如果为真 — 返回 <code>&#39;我不到三岁&#39;</code>。否则，会继续执行冒号 <code>&quot;:&quot;</code> 后的表达式，检查 <code>age &lt; 18</code>。</li>
<li> 如果为真 — 返回 <code>&#39;我不到18岁&#39;</code>。否则，会继续执行下一个冒号 <code>&quot;:&quot;</code> 后的表达式，检查 <code>age &lt; 100</code>。</li>
<li> 如果为真 — 返回 <code>&#39;我不到100岁&#39;</code>。否则，会继续执行最后一个冒号 <code>&quot;:&quot;</code> 后面的表达式，返回 <code>&#39;剩下就是我的岁数&#39;</code>。<br>有时候使用三元运算符是为了简便，但多了话就会很复杂，<strong>不建议这样使用三元运算符。</strong></li>
</ol>
<p><strong>tips：</strong> 建议每次使用 if 语句都用大括号 <code>&#123;&#125;</code> 来包装代码块，即使只有一条语句。这样可以提高代码可读性。</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>js中有三个常用的逻辑运算符：<code>||</code>（或），<code>&amp;&amp;</code>（与），<code>!</code>（非）。还有新增的非空运算符：<code>??</code></p>
<p>虽然它们被称为“逻辑”运算符，但这些运算符却可以被应用于任意类型的值，而不仅仅是布尔值。它们的结果也同样可以是任意类型。</p>
<h3 id="（或）"><a href="#（或）" class="headerlink" title="|| （或）"></a>|| （或）</h3><p>一个或运算 <code>||</code> 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。下面栗子将解释这段话。</p>
<p>两个竖线符号表示<code>||</code>“或”运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = a || b;</span><br></pre></td></tr></table></figure>
<p>用作于判断使用的话，有四种逻辑情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert( true || true ); // true </span><br><span class="line">alert( false || true ); // true</span><br><span class="line">alert( true || false ); // true</span><br><span class="line">alert( false || false ); // false</span><br></pre></td></tr></table></figure>
<p>用于表达式或者变量列表使用的话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let firstName = &quot;&quot;; // 假值</span><br><span class="line">let lastName = &quot;&quot;; // 假值</span><br><span class="line">let nickName = &quot;SuperCoder&quot;; // 真值</span><br><span class="line">alert( firstName || lastName || nickName || &quot;Anonymous&quot;); // SuperCoder</span><br></pre></td></tr></table></figure>
<p>前面变量的值都为假，结果就是 <code>&quot;Anonymous&quot;</code>。</p>
<h3 id="amp-amp-（与）"><a href="#amp-amp-（与）" class="headerlink" title="&amp;&amp;（与）"></a>&amp;&amp;（与）</h3><p>与运算返回第一个假值，如果没有假值就返回最后一个值。上面的规则和或运算很像。区别就是与运算返回第一个假值，而或运算返回第一个真值。</p>
<p>两个 &amp; 符号表示 <code>&amp;&amp;</code> 与运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = a &amp;&amp; b;</span><br></pre></td></tr></table></figure>
<p>跟或运算符不一样的是，当值都为真值时才会返回true，这里也举四个栗子跟或运算符做比较：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert( true &amp;&amp; true ); // true</span><br><span class="line">alert( false &amp;&amp; true ); // false</span><br><span class="line">alert( true &amp;&amp; false ); // false </span><br><span class="line">alert( false &amp;&amp; false ); // false</span><br></pre></td></tr></table></figure>
<h3 id="（非）"><a href="#（非）" class="headerlink" title="!（非）"></a>!（非）</h3><p>感叹符号 <code>!</code> 表示布尔非运算符。</p>
<p>在第一篇的不等于（<code>!==</code>）使用过</p>
<p>逻辑非运算符接受一个参数，并按如下运作：</p>
<ol>
<li> 将操作数转化为布尔类型：<code>true/false</code>。</li>
<li> 返回相反的值。<br>有时候我们会看到有两个<code>!!</code>是用来将某个值转化为布尔类型<h3 id="（非空运算符）"><a href="#（非空运算符）" class="headerlink" title="??（非空运算符）"></a>??（非空运算符）</h3>与 （<code>||</code>） 或运算符一样,唯一不一样的仅当值为 null 或 undefined 时才当为假值，其余都为真。</li>
</ol>
<p>在非空运算符基础上还能简写<code>??= </code>空赋值运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x = null</span><br><span class="line">let y = 5</span><br><span class="line">alert(x ??= y) // =&gt; 5</span><br></pre></td></tr></table></figure>
<p>拆分为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x = null</span><br><span class="line">let y = 5</span><br><span class="line">alert(x = (x ?? y)) // =&gt; 5</span><br></pre></td></tr></table></figure>
<p>但是出于安全原因，JavaScript 禁止将 <code>??</code> 运算符与 <code>&amp;&amp;</code> 和 <code>||</code> 运算符一起使用，除非使用括号明确指定了优先级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x = 1 &amp;&amp; 2 ?? 3; // Syntax error</span><br></pre></td></tr></table></figure>
<p><strong>tips：</strong> </p>
<ul>
<li>优先级 <code>!</code> &gt; <code>&amp;&amp;</code> &gt; <code>||</code></li>
<li>  <code>??</code> 运算符的优先级非常低，仅略高于 <code>?</code> 和 <code>=</code>，因此在表达式中使用它时请考虑添加括号。</li>
<li>  如果没有明确添加括号，不能将其与 <code>||</code> 或 <code>&amp;&amp;</code> 一起使用。<h2 id="for和while"><a href="#for和while" class="headerlink" title="for和while"></a>for和while</h2></li>
</ul>
<p><strong>循环</strong> 是一种重复运行同一代码的方法。</p>
<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a><code>while</code> 循环</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (condition) &#123;</span><br><span class="line">// 代码 </span><br><span class="line">// 所谓的“循环体”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>condition</code> 为真时，执行循环体的 <code>code</code>。</p>
<p>例如，以下将循环输出当 <code>i &lt; 3</code> 时的 <code>i</code> 值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let i = 0; </span><br><span class="line">while (i &lt; 3) &#123; // 依次显示 0、1 和 2 </span><br><span class="line">    alert( i ); </span><br><span class="line">    i++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环体的单次执行叫作 <strong>一次迭代</strong>。上面示例中的循环进行了三次迭代。</p>
<p>如果上述示例中没有 <code>i++</code>，那么循环（理论上）会永远重复执行下去，称为“死循环”。浏览器提供了阻止这种循环的方法，我们可以通过终止进程，来停掉服务器端的 JavaScript。</p>
<p>当循环体只有一条语句，则可以省略大括号 <code>&#123;…&#125;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let i = 3; </span><br><span class="line">while (i) alert(i--);</span><br></pre></td></tr></table></figure>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h3><p><code>for</code> 循环更加复杂，但它是最常使用的循环形式。</p>
<p><code>for</code> 循环看起来就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (begin; condition; step) &#123; </span><br><span class="line">    // ……循环体…… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    // 结果为 0、1、2 </span><br><span class="line">    alert(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析 <code>for</code> 循环：<br>begin     | <code>i = 0</code>    | 进入循环时执行一次。                  |<br>| ——— | ———- | ————————— |<br>| condition | <code>i &lt; 3</code>    | 在每次循环迭代之前检查，如果为 false，停止循环。 |<br>| body（循环体） | <code>alert(i)</code> | 条件为真时，重复运行。                 |<br>| step      | <code>i++</code>      | 在每次循环体迭代后执行。</p>
<p><code>for</code>循环算法的工作原理如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始运行 </span><br><span class="line">→ (如果 condition 成立 → 运行 body 然后运行 step) </span><br><span class="line">→ (如果 condition 成立 → 运行 body 然后运行 step) </span><br><span class="line">→ (如果 condition 成立 → 运行 body 然后运行 step) </span><br><span class="line">→ ...</span><br></pre></td></tr></table></figure>
<p>把工作原理使用到栗子上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// for (let i = 0; i &lt; 3; i++) alert(i) </span><br><span class="line"></span><br><span class="line">// 开始 </span><br><span class="line">let i = 0 </span><br><span class="line">// 如果条件为真，运行下一步 </span><br><span class="line">if (i &lt; 3) &#123; alert(i); i++ &#125; </span><br><span class="line">// 如果条件为真，运行下一步 </span><br><span class="line">if (i &lt; 3) &#123; alert(i); i++ &#125; </span><br><span class="line">// 如果条件为真，运行下一步 </span><br><span class="line">if (i &lt; 3) &#123; alert(i); i++ &#125; </span><br><span class="line">// ……结束，因为现在 </span><br><span class="line">i == 3</span><br></pre></td></tr></table></figure>
<h4 id="省略语句"><a href="#省略语句" class="headerlink" title="省略语句"></a>省略语句</h4><p><code>for</code>条件中需要三个条件，这些如果不需要的话是可以省略掉的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let i = 0; </span><br><span class="line">// 我们已经声明了 i 并对它进行了赋值 </span><br><span class="line">for (; i &lt; 3; i++) &#123; // 不再需要 &quot;begin&quot; 语句段 </span><br><span class="line">    alert( i ); // 0, 1, 2 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略了<code>begin</code>参数，但 <strong>;</strong> 是一定要存在的。我们也可以移除 <code>step</code> 语句段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let i = 0; </span><br><span class="line">for (; i &lt; 3;) &#123; </span><br><span class="line">    alert( i++ ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写法跟<code>while (i &lt; 3)</code> 等价。 <code>for</code> 的两个 <code>;</code> 必须存在，否则会出现语法错误。</p>
<p><code>for</code>还有语句：</p>
<table>
<thead>
<tr>
<th><code>break</code></th>
<th>强制退出循环</th>
</tr>
</thead>
<tbody><tr>
<td><code>continue</code></td>
<td><code>break</code> 的“轻量版”。它不会停掉整个循环。而是停止当前这一次迭代，并强制启动新一轮循环（如果条件允许的话）。</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>温故而知新（巩固js基础第一篇）</title>
    <url>/2024/05/20/base/</url>
    <content><![CDATA[<p>js为什么要单独开一个文件存放：<br>js在浏览器作为单独文件有一个好处就是浏览器会下载它，然后保存到浏览器的缓存中。<br>之后，其他页面想要相同的脚本就会从缓存中获取，而不是下载它。所以文件实际上只会下载一次。<br>这可以节省流量，并使得页面（加载）更快。</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>代码结构的第一件事就是学会构建代码块。为什么？提高可读性</p>
<p><strong>语句：</strong> 通常，每条语句独占一行，以提高代码的可读性</p>
<p><strong>分号：</strong> 一个很少被重视的问题，因为在<strong>大多数情况</strong>下可以省略分号。<strong>但是“大多数情况”并不意味着“总是”！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 举个栗子 */</span><br><span class="line"></span><br><span class="line">alert(&quot;There will be an error&quot;)</span><br><span class="line"></span><br><span class="line">[1, 2].forEach(alert)</span><br></pre></td></tr></table></figure>
<p>如果我们运行代码，只有第一个 <code>alert</code> 语句的内容被显示了出来，随后我们收到了一个错误！为什么？因为在js并不会在方括号 <code>[...]</code> 前添加一个隐式的分号。</p>
<p>第一个例子中的代码改为一条简单的语句，我们从引擎看到的是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(&quot;There will be an error&quot;)[1, 2].forEach(alert)</span><br></pre></td></tr></table></figure>
<p><strong>怎么解决：</strong> 我们在第一个 <code>alert(&quot;There will be an error&quot;);</code> 语句末尾加上一个分号，就工作正常了 。</p>
<p><strong>tips：</strong> 避免这种情况除了习惯的写完一条语句后在后面添加分号，还可以使用快捷格式化方式也可以达到语句后面自动加上分号。在vscode编译器的情况下要去除自动添加分号的话，安装  prettier 插件，在settings.json中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;vetur.format.defaultFormatterOptions&quot;: &#123;</span><br><span class="line">    &quot;prettier&quot;: &#123;</span><br><span class="line">        &quot;semi&quot;: false,</span><br><span class="line">        &quot;singleQuote&quot;: true</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注释：</strong> 利用好注释可以省很多代码上的沟通和理解，但也要减少没必要的注释，栗子<code>name // 姓名</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  单行注释 //</span><br><span class="line">  多行注释 /* */</span><br><span class="line">  jsDoc注释 更多用于构造函数</span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line">*  解释该函数有什么作用</span><br><span class="line"></span><br><span class="line">* @constructor</span><br><span class="line"></span><br><span class="line">* @param &#123;参数类型&#125; title - 参数</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><strong>tips：</strong> 注释不能嵌套注释，否则会报错</p>
<h1 id="现代模式（严格模式），”use-strict”"><a href="#现代模式（严格模式），”use-strict”" class="headerlink" title="现代模式（严格模式），”use strict”"></a>现代模式（严格模式），”use strict”</h1><p><strong>什么是现代模式（严格模式）</strong> js是不断进步的，一些新功能出来就有一些旧功能的抛弃，但为了兼容旧功能的代码就会保留着旧功能的使用。 <strong>“use strict”</strong> 这个指令看上去像一个字符串 <code>&quot;use strict&quot;</code> 或者 <code>&#39;use strict&#39;</code>。当它处于脚本文件的顶部时，那么整个脚本的文件都将进行 <strong>严格模式</strong>。 同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。</p>
<p><strong>为什么要使用</strong> 为了避免写js语法的一些不合理、不严谨之处，减少一些怪异行为</p>
<ul>
<li>  消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>  提高编译器效率，增加运行速度；</li>
<li>  为未来新版本的Javascript做好铺垫。</li>
</ul>
<p><strong>tips：</strong> <code>&quot;use strict&quot;</code> 指令只允许出现在脚本或函数的开头。否则严格模式可能无法启用。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>变量</code>是数据的“命名存储”。我们可以使用变量来保存商品、访客和其他信息。<br>使用<code>let var const</code>声明，才能使用变量</p>
<p><strong>注意事项：</strong> 1.大小写之分。2.允许非英文字母，但不推荐。3.不能用保留字来声明变量。4.未采用 <code>use strict</code> 下的赋值，在严格模式下直接赋值没有声明是会报错的，在普通模式下仍然可以正常工作，这是为了保持对旧脚本的兼容，所以要按严格模式变量都要进行声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 注意：这个例子中没有 &quot;use strict&quot; </span><br><span class="line">num = 5; </span><br><span class="line">// 如果变量 &quot;num&quot; 不存在，就会被创建 </span><br><span class="line">alert(num); // 5</span><br><span class="line"></span><br><span class="line">// 这个是有 &quot;use strict&quot; </span><br><span class="line">&quot;use strict&quot;; </span><br><span class="line">num = 5; // 错误：num 未定义</span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在 js 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）。<br><code>Number</code>（数字）<code>bigint</code>（整数）<code>String</code>（字符串）<code>Object</code>（对象 特殊类型）<code>Boolean</code>（布尔值）<code>Undefined</code>（独立类型）<code>Null</code>（独立类型）<code>Array</code>（数组）<code>Function</code>（函数）<code>Symbol</code>（新增类型）<code>typeof</code>（运算符）</p>
<p><strong>基本数据类型</strong></p>
<ul>
<li>  <code>number</code> 用于任何类型的数字：整数或浮点数，在 <code>±(253-1)</code> 范围内的整数。</li>
<li>  <code>bigint</code> 用于任意长度的整数。</li>
<li>  <code>string</code> 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。</li>
<li>  <code>boolean</code> 用于 <code>true</code> 和 <code>false</code>。</li>
<li>  <code>null</code> 用于未知的值 —— 只有一个 <code>null</code> 值的独立类型。</li>
<li>  <code>undefined</code> 用于未定义的值 —— 只有一个 <code>undefined</code> 值的独立类型。</li>
<li>  <code>symbol</code> 用于唯一的标识符。</li>
<li>  <code>object</code> 用于更复杂的数据结构</li>
</ul>
<p><strong>其他数据类型</strong><br>-<code>Array</code>用于数组[]数据结构</p>
<ul>
<li><code>Function</code>用于函数</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>字符串（string）转换</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let value = true;</span><br><span class="line">alert(typeof value); // boolean</span><br><span class="line">value = String(value); // 现在，值是一个字符串形式的 &quot;true&quot; </span><br><span class="line">alert(typeof value); // string</span><br><span class="line"></span><br><span class="line">字符串转换最明显。`false` 变成 `&quot;false&quot;`，`null` 变成 `&quot;null&quot;` 等。</span><br></pre></td></tr></table></figure>
<p><strong>数字型（number）转换</strong><br>在算术函数和表达式中，会自动进行 number 类型转换。 但 + 等于拼接， 栗子<code>&#39;1&#39;+&#39;1&#39;</code>会等于11，要手动转为数字才会相加<code>Number()</code>函数进行转换。如果该字符串不是一个有效的数字，转换的结果会是 <code>NaN</code></p>
<ul>
<li><code>undefined</code> 会变成 <code>NaN</code></li>
<li><code>null</code> 会变成 <code>0</code></li>
<li><code>true 和 false</code> 会变成<code>0 and 1</code></li>
<li><code>string</code> 会变成去掉首尾空格后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 <code>0</code>。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 <code>NaN</code>。</li>
</ul>
<h2 id="基础运算符"><a href="#基础运算符" class="headerlink" title="基础运算符"></a>基础运算符</h2><ol>
<li><strong>运算元：</strong> 运算符应用的对象。比如说乘法运算 <code>5 * 2</code>，有两个运算元：左运算元 <code>5</code> 和右运算元 <code>2</code>。更多称为“参数”而不是“运算元”。</li>
<li><strong>一元运算符：</strong> 如果一个运算符对应的只有一个运算元，那么它是 <strong>一元运算符</strong>。</li>
<li><strong>二元运算符：</strong> 如果一个运算符拥有两个运算元，那么它是 <strong>二元运算符</strong>。</li>
<li><strong>赋值运算符：</strong> <code>=</code> 也是一个运算符</li>
<li><strong>链式运算符</strong> 可读性不高，所以不常使用</li>
<li><strong>位运算符：</strong> 位运算符把运算元当做 32 位整数，并在它们的二进制表现形式上操作 。Web 开发中很少使用它们</li>
<li><strong>逗号运算符：</strong> 是最少见最不常使用的运算符之一。有时候它会被用来写更简短的代码。可读性不高，所以不常使用</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一元运算符作用是对数字进行正负转换</span><br><span class="line">let x = 1;</span><br><span class="line">x = -x;</span><br><span class="line">alert( x ); // -1，一元负号运算符生效</span><br><span class="line"></span><br><span class="line">二元运算符作用是对数字的算术</span><br><span class="line">let x = 1, y = 3;</span><br><span class="line">alert( y - x ); // 2，二元运算符减号做减运算</span><br><span class="line"></span><br><span class="line">链式运算符作用是对多个互相关联二元运算符以及赋值运算符时的简写，缺点可读性不高</span><br><span class="line">let a, b, c;</span><br><span class="line">a = b = c = 2 + 2;</span><br><span class="line">alert( a ); // 4 alert( b ); // 4 alert( c ); // 4</span><br><span class="line">出于可读性，最好将这种代码分成几行</span><br><span class="line">c = 2 + 2;</span><br><span class="line">b = c;</span><br><span class="line">a = c;</span><br><span class="line"></span><br><span class="line">缩写运算符</span><br><span class="line">let n = 2;</span><br><span class="line">n = n + 5;</span><br><span class="line">n = n * 2;</span><br><span class="line">可缩写为</span><br><span class="line">let n = 2;</span><br><span class="line">n += 5; // 现在 n = 7（等同于 n = n + 5）</span><br><span class="line">n *= 2; // 现在 n = 14（等同于 n = n * 2）</span><br><span class="line">alert( n ); // 14</span><br><span class="line">自增</span><br><span class="line">let counter = 2;</span><br><span class="line">counter++; // 和 counter = counter + 1 效果一样，但是更简洁 </span><br><span class="line">alert( counter ); // 3</span><br><span class="line">自减</span><br><span class="line">let counter = 2;</span><br><span class="line">counter--; // 和 counter = counter - 1 效果一样，但是更简洁 </span><br><span class="line">alert( counter ); // 1</span><br><span class="line"></span><br><span class="line">逗号运算符</span><br><span class="line">let a = (1 + 2, 3 + 4);</span><br><span class="line">alert( a ); // 7（3 + 4 的结果）</span><br></pre></td></tr></table></figure>
<p>二元运算符支持以下数学运算：</p>
<ul>
<li>  加法 <code>+</code></li>
<li>  减法 <code>-</code></li>
<li>  乘法 <code>*</code></li>
<li>  除法 <code>/</code></li>
<li>  取余 <code>%</code>： 取余运算符是 <code>%</code>，尽管它看起来很像百分数，但实际并无关联。一个表达式的值除以另一个表达式的值，返回余数。<strong>公式</strong>：result = numberA % numberB <strong>返回值</strong>：result，任何变量 <strong>参数</strong>：numberA，任何数值表达式。；numberB，任何数值表达式。 <strong>说明</strong>：取余（或余数）运算符用 number1 除以 number2 （把浮点数四舍五入为整数），然后只返回余数作为 result。</li>
<li>  求幂 <code>**</code>：求幂运算 <code>a ** b</code> 是 <code>a</code> 乘以自身 <code>b</code> 次。</li>
</ul>
<p>位运算符：</p>
<ul>
<li>  按位与 ( <code>&amp;</code> )</li>
<li>  按位或 ( <code>|</code> )</li>
<li>  按位异或 ( <code>^</code> )</li>
<li>  按位非 ( <code>~</code> )</li>
<li>  左移 ( <code>&lt;&lt;</code> )</li>
<li>  右移 ( <code>&gt;&gt;</code> )</li>
<li>  无符号右移 ( <code>&gt;&gt;&gt;</code> )</li>
</ul>
<p><strong>tips：</strong> 一元运算符优先级高于二元运算符，自增/自减只能应用于变量。运算符都有优先级。</p>
<h2 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h2><ul>
<li><code>&lt;</code> 小于</li>
<li><code>&gt;</code> 大于</li>
<li><code>&gt;=</code> 大于等于</li>
<li><code>&lt;=</code> 小于等于</li>
<li><code>==</code> 等于</li>
<li><code>===</code> 全等</li>
<li><code>!=</code> 不等于</li>
<li><code>!==</code> 不全等<br>等于与全等区别：等于不进行数据类型判断，全等会进行判断。<br>栗子：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">它们不相等，因为它们属于不同的类型。</span><br><span class="line">alert( null === undefined ); // false</span><br><span class="line">仅仅等于对方而不等于其他任何的值</span><br><span class="line">alert( null == undefined ); // true</span><br></pre></td></tr></table></figure>
<p><strong>tips：</strong> <code>undefined</code> 不应该被与其他值进行比较</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Fiddler替换域名</title>
    <url>/2024/05/20/fiddler/</url>
    <content><![CDATA[<h1 id="通过fiddler替换域名"><a href="#通过fiddler替换域名" class="headerlink" title="通过fiddler替换域名"></a>通过fiddler替换域名</h1><blockquote>
<p>ps：提前安装好fiddler以及配置好</p>
</blockquote>
<h2 id="替换app里h5页面"><a href="#替换app里h5页面" class="headerlink" title="替换app里h5页面"></a>替换app里h5页面</h2><p>腾讯视频为例原型：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba08542460534507812fb85abad08c6d~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba08542460534507812fb85abad08c6d~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="19c4b8a480bb7e8fc81e518c44cf88a.jpg"></p>
<p>点击打开广告的h5页</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dce3f409cb864d1ebdd667e81796f173~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dce3f409cb864d1ebdd667e81796f173~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="8042ec1bcecec048880a518694621e6.jpg"></p>
<p>通过fiddler可以替换域名，变为访问我们个人链接</p>
<h3 id="1、打开主角Fiddler"><a href="#1、打开主角Fiddler" class="headerlink" title="1、打开主角Fiddler"></a>1、打开主角Fiddler</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c618b4629acc40888e8df89eedfd5038~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c618b4629acc40888e8df89eedfd5038~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h3 id="2、找到我们要更改的url"><a href="#2、找到我们要更改的url" class="headerlink" title="2、找到我们要更改的url"></a>2、找到我们要更改的url</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eaccf6705254480892a91c21d7476c7~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eaccf6705254480892a91c21d7476c7~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h3 id="3、点开AutoResponder"><a href="#3、点开AutoResponder" class="headerlink" title="3、点开AutoResponder"></a>3、点开AutoResponder</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99cdda6533734446ba5f7fa773996a2e~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99cdda6533734446ba5f7fa773996a2e~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h3 id="4、操作"><a href="#4、操作" class="headerlink" title="4、操作"></a>4、操作</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92ca74a5f4e4c0aadf35c00e1c160a5~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92ca74a5f4e4c0aadf35c00e1c160a5~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<p>全勾选上</p>
<p>最重要的操作：</p>
<p>点击Add rule</p>
<p>第一条输入框：regex:(?inx)^原先的域名*</p>
<p>第二条输入框：复制我们要更改的域名</p>
<p>右边点击保存</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/542b4a7544fd44f68088b8a81e082acc~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/542b4a7544fd44f68088b8a81e082acc~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h3 id="5、完成"><a href="#5、完成" class="headerlink" title="5、完成"></a>5、完成</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0e66ff4383c43a7afdbb5c4019f83d0~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0e66ff4383c43a7afdbb5c4019f83d0~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="1ad0a52bf075b2e42e2b9417900e0bc.jpg"></p>
]]></content>
      <tags>
        <tag>fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title>privacy-policy</title>
    <url>/2024/05/20/game-privacy-policy/</url>
    <content><![CDATA[<p>Game Privacy Policy</p>
<p>Introduction</p>
<p>This Privacy Policy outlines how we, as the developer and operator of the Game, collect, use, disclose, and otherwise process your personal information when you access and use our Game. We are committed to protecting your privacy and ensuring that your personal information is handled securely and responsibly.</p>
<p>Collection of Personal Information</p>
<p>When you use our Game, we may collect certain personal information about you, such as:</p>
<p>Your username and password or other login credentials<br>Your game progress, scores, achievements, and other related gameplay data<br>Device information, including IP address, device ID, and operating system details<br>Information about your interactions with the Game, such as your preferences, settings, and in-game behavior<br>Please note that we do not intentionally collect any sensitive personal information about you, unless explicitly stated and with your consent.</p>
<p>Use of Personal Information</p>
<p>We use your personal information for the following purposes:</p>
<p>To provide you with access to and functionality of the Game<br>To monitor and improve the Game’s performance and user experience<br>To analyze gameplay data to develop and improve our services<br>To contact you regarding the Game, such as providing updates, announcements, or support<br>To comply with applicable legal requirements and respond to legal inquiries<br>Disclosure of Personal Information</p>
<p>We may share your personal information with third parties in the following limited circumstances:</p>
<p>With our service providers and partners who assist us in operating and improving the Game<br>In response to legal requests, such as subpoenas or court orders<br>If we believe it is necessary to protect our rights, property, or safety, or the rights, property, or safety of others<br>Protection of Personal Information</p>
<p>We employ reasonable technical, administrative, and physical measures to safeguard the security and confidentiality of your personal information. However, please note that no transmission of data over the internet or any form of electronic storage is completely secure. While we strive to protect your personal information, we cannot guarantee its absolute security.</p>
<p>Children’s Privacy</p>
<p>Our Game is not intended for children under the age of 13. If you are a parent or guardian and believe that your child has provided us with personal information without your consent, please contact us immediately to request deletion of such information.</p>
<p>Changes to Privacy Policy</p>
<p>We may update this Privacy Policy from time to time to reflect changes in our practices or applicable laws. We will notify you of any significant changes by posting an updated version on our website or within the Game. It is your responsibility to review this Privacy Policy periodically for updates.</p>
<p>Contact Information</p>
<p>If you have any questions or concerns about this Privacy Policy or our handling of your personal information, please feel free to contact us at [insert contact information]. We will do our best to respond to your inquiries in a timely manner.</p>
<p>Thank you for your trust and support in using our Game. We value your privacy and will continue to strive to protect it.</p>
]]></content>
      <tags>
        <tag>game-privacy-policy</tag>
      </tags>
  </entry>
  <entry>
    <title>provide/inject调用hook</title>
    <url>/2021/01/10/provide-or-inject/</url>
    <content><![CDATA[<h1 id="provide-inject调用hook"><a href="#provide-inject调用hook" class="headerlink" title="provide/inject调用hook"></a>provide/inject调用hook</h1><blockquote>
<p>ps：hook函数每一次调用都会重新执行，导致有些数据子组件要用又重新执行生命周期一遍</p>
</blockquote>
<p>用到的provide/inject、symbol来封装可传递性的hook方法。这里用到是因为symbol类型是唯一、不可变的标识符</p>
<h2 id="useProvider"><a href="#useProvider" class="headerlink" title="useProvider"></a>useProvider</h2><p>provide是一个对象，或者是一个返回对象的函数，需要属性名以及属性值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@template <span class="variable">T</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;T&#125;</span> </span>func Hook函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any[]&#125;</span> </span>args 调用Hook函数的参数列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;ReturnType&lt;T&gt;&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useProvider</span>(<span class="params">func, ...args</span>) </span>&#123;</span><br><span class="line">  !func.token &amp;&amp; (func.token = <span class="built_in">Symbol</span>(func.name || <span class="string">&#x27;functional store&#x27;</span>));</span><br><span class="line">  <span class="keyword">const</span> depends = func(...args);</span><br><span class="line">  provide(func.token, depends);</span><br><span class="line">  <span class="keyword">return</span> depends;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useInjector"><a href="#useInjector" class="headerlink" title="useInjector"></a>useInjector</h2><p>inject属性值是一个字符串数组，或者是一个对象。</p>
<p>只要判断唯一标识定义的token，就可以拿到该有的属性值返回。封装就是为了复用、便利在传参是否没有provide的情况下可以自助创建。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@template <span class="variable">T</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;T&#125;</span> <span class="variable">func</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;ReturnType&lt;T&gt;&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useInjector</span>(<span class="params">func, autoProvide = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> token, name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func === <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">    token = func;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    token = func.token;</span><br><span class="line">    name = func.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> res = token ? inject(token) : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">    <span class="keyword">if</span> (autoProvide) &#123;</span><br><span class="line">      res = useProvider(func);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`状态钩子函数<span class="subst">$&#123;name || token&#125;</span>未在上层组件通过调用useProvider提供`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手搭建简易版脚手架</title>
    <url>/2020/06/03/simple-npm/</url>
    <content><![CDATA[<p><strong>前言：</strong> 使用过那么多脚手架，自己也实现一个简易版的</p>
<h2 id="了解美化脚手架依赖包："><a href="#了解美化脚手架依赖包：" class="headerlink" title="了解美化脚手架依赖包："></a>了解美化脚手架依赖包：</h2><h3 id="1、commander"><a href="#1、commander" class="headerlink" title="1、commander"></a>1、commander</h3><p>这是用来编写指令和处理命令行的，具体用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const program = require(&quot;commander&quot;);</span><br><span class="line">// 定义指令</span><br><span class="line">program</span><br><span class="line"> .version(&#x27;0.0.1&#x27;)</span><br><span class="line"> .command(&#x27;init&#x27;, &#x27;Generate a new project from a template&#x27;)</span><br><span class="line"> .action(() =&gt; &#123;</span><br><span class="line"> // 回调函数</span><br><span class="line"> &#125;)</span><br><span class="line">// 解析命令行参数</span><br><span class="line">program.parse(process.argv);</span><br></pre></td></tr></table></figure>
<p>回忆一下，我们曾用过的 vue init 的命令就是这样声明的。</p>
<h3 id="2、inquirer"><a href="#2、inquirer" class="headerlink" title="2、inquirer"></a>2、inquirer</h3><p>这是个强大的交互式命令行工具，具体用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const inquirer = require(&#x27;inquirer&#x27;);</span><br><span class="line">inquirer</span><br><span class="line"> .prompt([</span><br><span class="line"> // 一些交互式的问题</span><br><span class="line"> ])</span><br><span class="line"> .then(answers =&gt; &#123;</span><br><span class="line"> // 回调函数，answers 就是用户输入的内容，是个对象</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3、chalk"><a href="#3、chalk" class="headerlink" title="3、chalk"></a>3、chalk</h3><p> 这是用来修改控制台输出内容样式的，比如颜色啊，具体用法如下：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const chalk = require(&#x27;chalk&#x27;);</span><br><span class="line">console.log(chalk.green(&#x27;success&#x27;));</span><br><span class="line">console.log(chalk.red(&#x27;error&#x27;));</span><br></pre></td></tr></table></figure></p>
<h3 id="4、ora"><a href="#4、ora" class="headerlink" title="4、ora"></a>4、ora</h3><p>这是一个好看的加载，就是你下载的时候会有个转圈圈的那种效果，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const ora = require(&#x27;ora&#x27;)</span><br><span class="line">let spinner = ora(&#x27;downloading template ...&#x27;)</span><br><span class="line">spinner.start()</span><br></pre></td></tr></table></figure>
<h3 id="5、download-git-repo"><a href="#5、download-git-repo" class="headerlink" title="5、download-git-repo"></a>5、download-git-repo</h3><p>看名字很明显了，这是用来下载远程模板的，支持 GitHub、 GitLab 和 Bitbucket 等，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const download = require(&#x27;download-git-repo&#x27;)</span><br><span class="line">download(repository, destination, options, callback)</span><br></pre></td></tr></table></figure>
<p>其中 repository 是远程仓库地址；destination 是存放下载的文件路径，也可以直接写文件名，默认就是当前目录；options 是一些选项，比如 { clone：boolean } 表示用 http download 还是 git clone 的形式下载。</p>
<h2 id="开始："><a href="#开始：" class="headerlink" title="开始："></a>开始：</h2><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>准备工作新建文件夹、在目录下执行npm init 命令 会生成一个生成 package.json 文件，在 package.json 里面写入以下依赖并执行 npm install 安装，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line"> &quot;chalk&quot;: &quot;^2.4.2&quot;,</span><br><span class="line"> &quot;commander&quot;: &quot;^2.19.0&quot;,</span><br><span class="line"> &quot;download-git-repo&quot;: &quot;^1.1.0&quot;,</span><br><span class="line"> &quot;inquirer&quot;: &quot;^6.2.2&quot;,</span><br><span class="line"> &quot;ora&quot;: &quot;^3.2.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个 bin 文件夹，并在 bin 目录下新建一个无后缀名的 xr 文件，并写上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">console.log(&#x27;hello&#x27;);</span><br></pre></td></tr></table></figure>
<p>这个文件就是我们整个脚手架的入口文件，我们用 node ./bin/xr 运行一下，就能在控制台打印出 hello<br>这里要注意开头的 #!/usr/bin/env node<br>这个语句必须加上，主要是为了让系统看到这一行的时候，会沿着该路径去查找 node 并执行，主要是为了兼容 Mac ，确保可执行。</p>
<h3 id="bin-目录初始化"><a href="#bin-目录初始化" class="headerlink" title="bin 目录初始化"></a>bin 目录初始化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">const program = require(&#x27;commander&#x27;)</span><br><span class="line"></span><br><span class="line">// 定义当前版本</span><br><span class="line">// 定义使用方法</span><br><span class="line">// 定义四个指令</span><br><span class="line">program</span><br><span class="line"> .version(require(&#x27;../package&#x27;).version)</span><br><span class="line"> .usage(&#x27;&lt;command&gt; [options]&#x27;)</span><br><span class="line"> .command(&#x27;add&#x27;, &#x27;add a new template&#x27;)</span><br><span class="line"> .command(&#x27;delete&#x27;, &#x27;delete a template&#x27;)</span><br><span class="line"> .command(&#x27;list&#x27;, &#x27;list all the templates&#x27;)</span><br><span class="line"> .command(&#x27;init&#x27;, &#x27;generate a new project from a template&#x27;)</span><br><span class="line"> </span><br><span class="line">// 解析命令行参数</span><br><span class="line">program.parse(process.argv)</span><br></pre></td></tr></table></figure>
<h3 id="发布到-npm"><a href="#发布到-npm" class="headerlink" title="发布到 npm"></a>发布到 npm</h3><p>既然以上命令都执行成功了，那接下来我们就把它发布到 npm 上。</p>
<ul>
<li>  删除 test 文件夹，它就本地测试用的</li>
<li>  在根目录下新建 README.md 文件，使用说明</li>
<li>  在根目录下新建 .npmignore 文件，并写入 /node_modules ，意思就是发布的时候忽略 node_modules 文件夹，</li>
<li>  去 npm 官网注册个账号</li>
<li>  现在让我们回到项目根目录，执行 npm login 登入 npm 账号，再执行 npm publish 发布</li>
<li>  发布完成后使用一下，是否能正常运行。这里我们记得先用 npm unlink 解绑一下命令，不然会相互影响。下面我们打开终端，输入 npm i xr-cli -g 全局安装一下脚手架，然后执行 xr</li>
</ul>
]]></content>
      <tags>
        <tag>Npm</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底搞懂this指向</title>
    <url>/2024/05/20/this/</url>
    <content><![CDATA[<h1 id="搞懂this指向"><a href="#搞懂this指向" class="headerlink" title="搞懂this指向"></a>搞懂this指向</h1><blockquote>
<p>ps 为什么要搞懂this？因为JavaScript是面向对象编程，而this指向的就是对象</p>
</blockquote>
<h2 id="谁调用就指向谁"><a href="#谁调用就指向谁" class="headerlink" title="谁调用就指向谁"></a>谁调用就指向谁</h2><p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">    var name = &quot;测试&quot;;</span><br><span class="line">    console.log(this.name); // &#x27;&#x27;</span><br><span class="line">    console.log(this); // window</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>this最终指向的是调用它的对象，这里的函数test实际是被Window对象所点出来的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">    var name = &quot;测试&quot;;</span><br><span class="line">    console.log(this.name); // &#x27;&#x27;</span><br><span class="line">    console.log(this); // window</span><br><span class="line">&#125;</span><br><span class="line">window.test();</span><br></pre></td></tr></table></figure>

<p>效果是一样的，因为定义的函数也是window的一个属性。</p>
<p>在看另外个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var test = &#123;</span><br><span class="line">    name: &#x27;测试&#x27;,</span><br><span class="line">    fn: function() &#123;</span><br><span class="line">        console.log(this.name); // 测试</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">test.fn()</span><br></pre></td></tr></table></figure>

<p>这里this是指向对象test,按说法谁调用它就指向谁，那自然就是对象test。当然要在函数创建后这个说法才成立。</p>
<h2 id="this永远指向的是最后调用它"><a href="#this永远指向的是最后调用它" class="headerlink" title="this永远指向的是最后调用它"></a>this永远指向的是最后调用它</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var test = &#123;</span><br><span class="line">    age:10,</span><br><span class="line">    test2:&#123;</span><br><span class="line">        age:12,</span><br><span class="line">        fn:function()&#123;</span><br><span class="line">            console.log(this.age); //undefined</span><br><span class="line">            console.log(this); //window</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var call = test.test2.fn;</span><br><span class="line">call();</span><br></pre></td></tr></table></figure>

<p>这里指向的是window，因为this永远指向的是最后调用它的，也就是看它执行的时候是谁调用的。这个例子虽然函数fu是被test2所引用，但是在将fn赋值给变量call的时候并没有执行所以最终指向的是window</p>
<h2 id="构造函数版this"><a href="#构造函数版this" class="headerlink" title="构造函数版this"></a>构造函数版this</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">    this.user = &quot;测试&quot;;</span><br><span class="line">&#125;</span><br><span class="line">var test = new fn();</span><br><span class="line">console.log(test.user); // 测试</span><br></pre></td></tr></table></figure>

<p>这里之所以对象test可以点出函数Fn里面的user是因为new关键字可以改变this的指向，用了new关键字就是创建一个对象实例，我们这里用变量test创建了一个fn的实例（相当于复制了一份Fn到对象test里面），此时仅仅只是创建，并没有执行，而调用这个函数fn的是对象test，那么this指向的自然是对象test。</p>
<blockquote>
<p>首先new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代。</p>
</blockquote>
<h2 id="当this碰到return时"><a href="#当this碰到return时" class="headerlink" title="当this碰到return时"></a>当this碰到return时</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function fn()  </span><br><span class="line">&#123;  </span><br><span class="line">    this.user = &#x27;测试&#x27;;  </span><br><span class="line">    return &#123;&#125;;  </span><br><span class="line">&#125;</span><br><span class="line">var test = new fn;  </span><br><span class="line">console.log(test.user); //undefined</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function fn()  </span><br><span class="line">&#123;  </span><br><span class="line">    this.user = &#x27;测试&#x27;;  </span><br><span class="line">    return 1;  </span><br><span class="line">&#125;</span><br><span class="line">var test = new fn;  </span><br><span class="line">console.log(test.user); //测试</span><br></pre></td></tr></table></figure>

<p>如果函数返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</p>
<h2 id="自行改变this的指向"><a href="#自行改变this的指向" class="headerlink" title="自行改变this的指向"></a>自行改变this的指向</h2><p>开发环境的数据，测试环境没有开发环境的数据，只有改变环境才能更换数据。call,apply,bind 就是一般用来指定this的环境</p>
<h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var test = &#123;</span><br><span class="line">    age:10,</span><br><span class="line">    test2:&#123;</span><br><span class="line">        age:12,</span><br><span class="line">        fn:function()&#123;</span><br><span class="line">            console.log(this.age); //undefined</span><br><span class="line">            console.log(this); //window</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fn2 = test.test2.fn;</span><br><span class="line">fn2();</span><br></pre></td></tr></table></figure>

<p>这里fn2指向的是window，通过call方法，第一个参数可以将fn2 window环境指向为你需要的环境中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var test = &#123;</span><br><span class="line">    age:10,</span><br><span class="line">    test2:&#123;</span><br><span class="line">        age:12,</span><br><span class="line">        fn:function()&#123;</span><br><span class="line">            console.log(this.age); // 12</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fn2 = test.test2.fn;</span><br><span class="line">fn2.call(test);</span><br></pre></td></tr></table></figure>

<p>也可以添加多个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var test = &#123;</span><br><span class="line">    age:10,</span><br><span class="line">    test2:&#123;</span><br><span class="line">        age:12,</span><br><span class="line">        fn:function(e, ee)&#123;</span><br><span class="line">            console.log(this.age); // 12</span><br><span class="line">            console.log(e+ee); //3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fn2 = test.test2.fn;</span><br><span class="line">fn2.call(test, 1, 2);</span><br></pre></td></tr></table></figure>

<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p>apply方法和call方法有些相似，它也可以改变this的指向，唯一不同的就是apply第二个参数只能是数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var test = &#123;</span><br><span class="line">    age:10,</span><br><span class="line">    test2:&#123;</span><br><span class="line">        age:12,</span><br><span class="line">        fn:function(e, ee)&#123;</span><br><span class="line">            console.log(this.age); // 12</span><br><span class="line">            console.log(e+ee); //6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fn2 = test.test2.fn;</span><br><span class="line">fn2.call(test,[1,2,3]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ps 注意如果call和apply的第一个参数写的是null，那么this指向的是window对象</p>
</blockquote>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>bind方法和call、apply方法有些不同,bind方法是返回的是一个修改过后的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var test = &#123;</span><br><span class="line">    age:10,</span><br><span class="line">    test2:&#123;</span><br><span class="line">        age:12,</span><br><span class="line">        fn:function()&#123;</span><br><span class="line">            console.log(this.age); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fn2 = test.test2.fn;</span><br><span class="line">fn2.bind(test);</span><br></pre></td></tr></table></figure>

<p>这样会发现是没有执行的，因为bind返回的是一个修改后的函数，没有调用他</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var test = &#123;</span><br><span class="line">    age:10,</span><br><span class="line">    test2:&#123;</span><br><span class="line">        age:12,</span><br><span class="line">        fn:function()&#123;</span><br><span class="line">            console.log(this.age); // 12</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fn2 = test.test2.fn;</span><br><span class="line">var fn3 = fn2.bind(test);</span><br><span class="line">fn3()</span><br></pre></td></tr></table></figure>

<p>这样就可以调用，当然bind也是支持多个参数的，用法跟call一样</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3配置404notFound</title>
    <url>/2021/12/03/vue3config404notFound/</url>
    <content><![CDATA[<h2 id="vue3配置404notFound"><a href="#vue3配置404notFound" class="headerlink" title="vue3配置404notFound"></a>vue3配置404notFound</h2><p>常规参数只匹配 url 片段之间的字符，用 <code>/</code> 分隔。其实在<a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1%E6%88%96-404-not-found-%E8%B7%AF%E7%94%B1">router官网</a>中有写可用正则来自定义，官网是这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 将匹配所有内容并将其放在 `$route.params.pathMatch` 下</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/:pathMatch(.*)*&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;NotFound&#x27;</span>, <span class="attr">component</span>: NotFound &#125;,</span><br><span class="line">  <span class="comment">// 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/user-:afterUser(.*)&#x27;</span>, <span class="attr">component</span>: UserGeneric &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在一般设置404页面路由的时候我们便是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/404&quot;</span>,</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;notFound&quot;</span>,</span><br><span class="line"><span class="attr">component</span>: notFound</span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;*&quot;</span>, <span class="comment">// 此处需特别注意置于最底部</span></span><br><span class="line"><span class="attr">redirect</span>: <span class="string">&quot;/404&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是使用的是vue3的话,会遇到这样的一个报错:</p>
<p>Catch all routes (“*”) must now be defined using a param with a custom regexp.</p>
<p>这个报错翻译过来就是捕获所有路由（“*”）现在必须使用带有自定义regexp的参数定义</p>
]]></content>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始建博客</title>
    <url>/2024/05/20/blog/</url>
    <content><![CDATA[<p><strong>前言：</strong> 想弄个博客网站，就会联想到不得有台服务器吗？不得搞数据库吗？不得注册域名吗？没事，如果都没有，那照样是能搭建一个博客的。这里就要记录如何使用<strong>GitHub</strong>来建属于自己的博客。</p>
<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>下载地址：<a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a> 可以安装 Stable 版本。安装完毕之后，确保环境变量配置好，能正常使用 <code>npm</code> 命令</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>Hexo是一个博客框架，Hexo 官方还提供了一个命令行工具，用于快速创建项目、页面、编译、部署 Hexo 博客，所以在这之前我们需要先安装 Hexo 的命令行工具。</p>
<p>安装命令<code>npm install -g hexo-cli</code></p>
<p>安装完毕后可以输入<code>hexo -v</code>查看是否有版本号，确保环境变量配置好，能正常使用 <code>hexo</code> 命令</p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ol>
<li>我们使用 Hexo 的命令行创建一个项目，首先使用新建一个文件夹，改为你需要的名字（建议纯英文），打开命令行输入下面命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init &#123;name&#125; //name是你的项目名</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b95d67b1c038406d8d1ebf7ee71677ca~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b95d67b1c038406d8d1ebf7ee71677ca~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<p>看到终端输出这样就完成了，文件夹下就会出现 Hexo 的初始化文件，包括 themes、scaffolds、source 等文件夹，这些内容暂且先不用管是做什么的，我们先知道有什么，然后一步步走下去看看都发生了什么变化</p>
<ol start="2">
<li>进入新生成的文件夹里面，然后调用 Hexo 的 generate 命令，将 Hexo 编译生成 HTML 代码，运行<code>hexo generate</code>命令后，可以看到输出结果里面包含了 js、css、font 等内容，并发现他们都处在了项目根目录下的 public 文件夹下面了</li>
<li>我们利用 Hexo 提供的 server 命令把博客在本地运行起来<code>hexo server</code>，运行之后命令行输出如下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>点开本地 4000 端口上就可以查看博客站点了，如图所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f824dfd20594266bcc4fdd86b69a847~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f824dfd20594266bcc4fdd86b69a847~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<p>到这里就已经把静态博客的架子已经搭建出来了</p>
<h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><p>接下来我们把这个博客架子放到<strong>GitHub Pages</strong>上面看是否能成功，成功之后我们可以再进行博客样式</p>
<ol>
<li>在部署之前我们需要先知道博客的部署地址，它需要对应 GitHub 的一个项目地址，首先在 GitHub 新建一个仓库，名称为 {username}.github.io，注意这个名比较特殊，必须要是 github.io 为后缀结尾的</li>
</ol>
<p>建成后打开项目文件根目录下的 _config.yml 文件，找到 Deployment 这个地方，把刚才新建的 Repository 的地址贴过来，然后指定分支为 master 分支，最终修改为如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:  </span><br><span class="line">    type: git  </span><br><span class="line">    repo: &#123;git repo ssh address&#125;  </span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<p>修改完后还需要额外安装一个支持 Git 的部署插件，名字叫做 hexo-deployer-git，有了它我们才可以顺利将其部署到 GitHub 上面，安装命令<code>npm install hexo-deployer-git --save</code>，安装完后就可以继续我们的部署</p>
<ul>
<li>  部署命令还是使用我们的<strong>hexo</strong>命令输出<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
运行到这步踩坑，没有在GitHub配置了ssh的话会让你输入，不然会一直运行失败，在GitHub配置好ssh就可以上传成功了。不会ssh配置可以<a href="https://juejin.cn/post/6981432302991573028">点击教程</a><br>成功后可以看到GitHub上传了什么</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66df853970d146439719d75b3653b04c~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66df853970d146439719d75b3653b04c~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<p>完成上面就可以实现自己的博客了，但是还没有配置好自己喜欢的主题和标题，hexo是支持修改站名和描述等等。<br>修改根目录下的 _config.yml 文件，找到 Site 区域，这里面可以配置站点标题 title、副标题 subtitle 等内容、关键字 keywords 等内容，比如我的就修改为如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 白墙博客</span><br><span class="line">subtitle: &#x27;一面白墙正在绘画&#x27;</span><br><span class="line">description: &#x27;主要编程为JavaScript、TypeScript、vue3.x&#x27;</span><br><span class="line">keywords: &#x27;JavaScript,TypeScript，vue3.x，Es系列，Css系列&#x27;</span><br><span class="line">author: 白墙</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<p>这样就完成了站点基本信息的配置，完成之后可以看到一些基本信息就修改过来了，页面效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dc6c502a74349cd9e36c3d4cd6a21fd~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dc6c502a74349cd9e36c3d4cd6a21fd~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>GitHub上有很多主题都可以拉取下拉使用更改，目前 Hexo 里面应用最多的主题基本就是 Next 主题了，它支持的插件和功能也极为丰富，配置了这个主题，我们的博客可以支持更多的扩展功能，比如阅览进度条、中英文空格排版、图片懒加载等等。<br>主题的 GitHub 地址是：<a href="https://github.com/theme-next/hexo-theme-next%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%8A%8A">https://github.com/theme-next/hexo-theme-next，我们可以直接把</a> master 分支 Clone 下来。<br>进入项目的根目录打开终端，运行下面命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>执行完毕之后 Next 主题的源码就会出现在项目的 themes/next 文件夹下。</p>
<p>然后我们需要修改下博客所用的主题名称，修改项目根目录下的 _config.yml 文件，找到 theme 字段，修改为 next 即可</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/976469bb59ca4e96a0e36c2265320ef7~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/976469bb59ca4e96a0e36c2265320ef7~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<p>然后本地重新开启服务，访问刷新下页面，就可以看到 next 主题就切换成功了，预览效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10345abcc3654d60a8cb87096ec78c09~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10345abcc3654d60a8cb87096ec78c09~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h3 id="主题样式"><a href="#主题样式" class="headerlink" title="主题样式"></a>主题样式</h3><p>next提供很多样式，风格不变，但整个布局位置不太一样，通过修改scheme字段即可，注意是next文件下的<code>_config.yml</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/354013e44be745639d74ad3fc0a90817~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/354013e44be745639d74ad3fc0a90817~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<p>刷新页面之后就会变成这种布局<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb6276f4231f44149f4efc5848744d42~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb6276f4231f44149f4efc5848744d42~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><p>avatar 这个就类似站点的头像，如果设置了这个，会在站点的作者信息旁边额外显示一个头像。红色箭头指向</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fb2b645f57e459c957e9fa0f31790a9~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fb2b645f57e459c957e9fa0f31790a9~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<p>把需要的图片放置themes/next/source/images/avatar.png 路径，然后在<code>_config.yml</code>文件下更改avatar配置，url位置上更改正确的路径</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a538a7990104a169b322027dd93b15a~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a538a7990104a169b322027dd93b15a~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<p>还有另外两个配置，rounded是配置是否为圆形，rotated鼠标移动过去是否可旋转</p>
<h3 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h3><p>RSS订阅是站点用来和其他站点之间共享内容的一种简易方式(也叫<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=40646&ss_c=ssc.citiao.link">聚合内容</a>)，即Really Simple Syndication(<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=40646&ss_c=ssc.citiao.link">简易信息聚合</a>)。通常被用于新闻和其他按顺序排列的网站。<br>博客一般是需要 RSS 订阅的，如果要开启 RSS 订阅，这里需要安装一个插件，叫做 hexo-generator-feed，安装完成之后，站点会自动生成 RSS Feed 文件，安装命令<code>npm install hexo-generator-feed --save</code>，安装完成之后不需要其他的配置，以后每次编译生成站点的时候就会自动生成 RSS Feed 文件了</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>博客写技术文必定出现的代码块，next也可以配置修改，修改 <code>_config.yml</code> 文件的 <code>codeblock</code> 区块如下</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1cddbd9c19c4f9cbf1b30aa89ba40cc~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1cddbd9c19c4f9cbf1b30aa89ba40cc~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<p>设置完如下：<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1d8f5c99abc4d7cabfdfcaa0b640dba~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1d8f5c99abc4d7cabfdfcaa0b640dba~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h3 id="阅读进度"><a href="#阅读进度" class="headerlink" title="阅读进度"></a>阅读进度</h3><p>reading_process，阅读进度。大家可能注意到有些站点的最上侧会出现一个细细的进度条，代表页面加载进度和阅读进度，修改 _config.yml 如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d139d45378e4f68880e64cf0d9566a4~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d139d45378e4f68880e64cf0d9566a4~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<p>设置完如下：<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/497cb85022214b599f7cceb492cd7ec7~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/497cb85022214b599f7cceb492cd7ec7~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><p>bookmark，书签，可以根据阅读历史记录，在下次打开页面的时候快速帮助我们定位到上次的位置，大家可以根据喜好开启和关闭</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/933c0a9ce0724d6f9382f9edd71f5255~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/933c0a9ce0724d6f9382f9edd71f5255~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h3 id="github-banner"><a href="#github-banner" class="headerlink" title="github_banner"></a>github_banner</h3><p>在一些技术博客上，大家可能注意到在页面的右上角有个 GitHub 图标，点击之后可以跳转到其源码页面，可以为 GitHub Repository 引流，permalink设为自己的GitHub链接，title是鼠标滑动过去显示的标题</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5946b3b0faac4695ac6a37687d7184bd~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5946b3b0faac4695ac6a37687d7184bd~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p>由于 Hexo 的博客是静态博客，而且也没有连接数据库的功能，所以它的评论功能是不能自行集成的，但可以集成第三方的服务。Next 主题里面提供了多种评论插件的集成，有 changyan | disqus | disqusjs | facebook_comments_plugin | gitalk | livere | valine | vkontakte 这些。这里使用gitalk。它是利用 GitHub 的 Issue 来当评论，样式也比较不错。<br>首先需要在 GitHub 上面注册一个 OAuth Application，链接为：<a href="https://github.com/settings/applications/new%EF%BC%8C%E6%B3%A8%E5%86%8C%E5%AE%8C%E6%AF%95%E4%B9%8B%E5%90%8E%E6%8B%BF%E5%88%B0">https://github.com/settings/applications/new，注册完毕之后拿到</a> Client ID、Client Secret 就可以了。</p>
<p>首先需要在 _config.yml 文件的 comments 区域配置使用 gitalk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Multiple Comment System Support</span><br><span class="line">comments:  </span><br><span class="line">    # Available values: tabs | buttons  </span><br><span class="line">    style: tabs  </span><br><span class="line">    # Choose a comment system to be displayed by default.  </span><br><span class="line">    # Available values: changyan | disqus | disqusjs | facebook_comments_plugin | gitalk | livere | valine | vkontakte  </span><br><span class="line">    active: gitalk</span><br></pre></td></tr></table></figure>
<p>然后找到 gitalk 配置，添加它的各项配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Gitalk</span><br><span class="line"># For more information: https://gitalk.github.io, https://github.com/gitalk/gitalk</span><br><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: white-wall</span><br><span class="line">  repo: white-wall.github.io # Repository name to store issues</span><br><span class="line">  client_id: &#123;your client id&#125; # GitHub Application Client ID</span><br><span class="line">  client_secret: &#123;your client secret&#125; # GitHub Application Client Secret</span><br><span class="line">  admin_user: white-wall # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class="line">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class="line">  # Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span><br><span class="line">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class="line">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class="line">  language: zh-CN</span><br></pre></td></tr></table></figure>
<p>添加上面配置后刷新后就会出现这样的样式</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9561e98e3e344c0e82782333555f3f94~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9561e98e3e344c0e82782333555f3f94~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h3 id="无刷新加载"><a href="#无刷新加载" class="headerlink" title="无刷新加载"></a>无刷新加载</h3><p>可能大家听说过 Ajax，没听说过 pjax，这个技术实际上就是利用 Ajax 技术实现了局部页面刷新，既可以实现 URL 的更换，又可以做到无刷新加载。</p>
<p>要开启这个功能需要先将 pjax 功能开启，然后安装对应的 pjax 依赖库，首先修改 _config.yml 修改<code>pjax: true</code></p>
<p>切换到 next 主题文件下，然后安装依赖库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd themes/next</span><br><span class="line">$ git clone https://github.com/theme-next/theme-next-pjax source/lib/pjax</span><br></pre></td></tr></table></figure>

<p>更多主题修改等配置可在<a href="https://hexo.io/docs/">https://hexo.io/docs/</a> 官网查看</p>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>一开始生成后细心的hexo已经给出这行命令了</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a9c9b0c940244cab46c9ce4ec3a39c0~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a9c9b0c940244cab46c9ce4ec3a39c0~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"><br><code>hexo new hello-hexo</code>运行这行命令就会出现在 <code>source/_posts</code> 文件夹下，是 MarkDown 格式。<br>在文章开头通过如下格式添加必要信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标题 # 自动创建，如 hello-worlddate: </span><br><span class="line">日期 # 自动创建，如 2019-09-22 01:47:21</span><br><span class="line">tags: </span><br><span class="line">    - 标签1</span><br><span class="line">    - 标签2</span><br><span class="line">    - 标签3</span><br><span class="line">categories:</span><br><span class="line">    - 分类1</span><br><span class="line">    - 分类2</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>开头下方撰写正文，MarkDown 格式书写即可。</p>
<p>这样在下次编译的时候就会自动识别标题、时间、类别等等，另外还有其他的一些参数设置，可以参考文档：<a href="https://hexo.io/zh-cn/docs/writing.html%E3%80%82">https://hexo.io/zh-cn/docs/writing.html。</a></p>
<h2 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h2><p>跟新建文章一样，在目录下输入<code>hexo new page tags</code>执行这个命令之后会自动帮我们生成一个 source/tags/index.md 文件，也是MarkDown格式的。我们可以在tags文件内我们可以自行添加一个 type 字段来指定页面的类型，如图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d07dbdad022e4895aada8e13b555b37a~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d07dbdad022e4895aada8e13b555b37a~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<p>在刚刚新建的文章文件中设置，如图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1183c2f021b41bd9be5c1b343223c39~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1183c2f021b41bd9be5c1b343223c39~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<p>设置完在主题的 _config.yml 文件将这个页面的链接添加到主菜单里面，修改 <code>menu</code> 把tags<code>#</code>去掉就可以达到打开标签页的效果，然后就可以到页面查看效果</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ad77127849c42fd981d1127da130c70~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ad77127849c42fd981d1127da130c70~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h2 id="搜索页"><a href="#搜索页" class="headerlink" title="搜索页"></a>搜索页</h2><p>添加搜索功能，需要先安装一个插件，叫做 hexo-generator-searchdb，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>然后在项目的 _config.yml 里面添加搜索设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:  </span><br><span class="line">    path: search.xml  </span><br><span class="line">    field: post  </span><br><span class="line">    format: html  </span><br><span class="line">    limit: 10000</span><br></pre></td></tr></table></figure>
<p>然后在主题的 _config.yml 里面修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/wzpan/hexo-generator-search</span><br><span class="line">local_search:  </span><br><span class="line">    enable: true </span><br><span class="line">    # If auto, trigger search by changing input. </span><br><span class="line">    # If manual, trigger search by pressing enter key or search button.  </span><br><span class="line">    trigger: auto </span><br><span class="line">    # Show top n results per article, show all results by setting to -1  top_n_per_article: 5 </span><br><span class="line">    # Unescape html strings to the readable one.  </span><br><span class="line">    unescape: false </span><br><span class="line">    # Preload the search data when the page loads.  </span><br><span class="line">    preload: false</span><br></pre></td></tr></table></figure>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0c4cf4e840e4632970da12abdcac0e0~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0c4cf4e840e4632970da12abdcac0e0~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h2 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h2><p>页面都需要有个404状态页面，博客也不例外，直接在根目录 source 文件夹新建一个 404.md 文件即可，内容可以仿照如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 404 Not Found</span><br><span class="line">date: 2021-09-20 10:41:27</span><br><span class="line">---</span><br><span class="line">&lt;center&gt;</span><br><span class="line">对不起，您所访问的页面不存在或者已删除。</span><br><span class="line">您可以&lt;a href=&quot;https://blog.white-wall.cn&quot;&gt;点击此处&lt;/a&gt;返回首页。</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;</span><br><span class="line">    whiteWall</span><br><span class="line">&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure>
<p>新建完也要在主题_config.yml中打开404的<code>#</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ec93034f57f416f9d8bde68e826235f~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ec93034f57f416f9d8bde68e826235f~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"></p>
<h2 id="部署脚本"><a href="#部署脚本" class="headerlink" title="部署脚本"></a>部署脚本</h2><p>其实方便后面一行代码就可以直接完成博客更新来配置，在根目录下新建一个 deploy.sh 的脚本文件，内容如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99669318d38949878b58893ecbcd509c~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99669318d38949878b58893ecbcd509c~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"><br>这样我们在部署发布的时候只需要执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh deploy.sh</span><br></pre></td></tr></table></figure>
<h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>GitHub还支持自定义域名的设置,在github项目 <code>setting</code>滑到看到page，设置完就可以看到这样提示</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6431043265a94e75b5ebd1cf696020c7~tplv-k3u1fbpfcp-watermark.image" class="lazy" data-srcset="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6431043265a94e75b5ebd1cf696020c7~tplv-k3u1fbpfcp-watermark.image" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image.png"><br>有一个值得注意的地方，如果配置了自定义域名，在目前的情况下，每次部署的时候这个自定义域名的设置是会被自动清除的。所以为了避免这个情况，我们需要在项目目录下面新建一个 CNAME 文件，路径为 source/CNAME，内容就是自定义域名。</p>
<p>比如我就在 source 目录下新建了一个 CNAME 文件，内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blog.white-wall.cn</span><br></pre></td></tr></table></figure>
<p>##tips:## 配置自定义域名，需要自行购买有效的域名才可配置，否则会打不开</p>
]]></content>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
