[{"title":"privacy-policy","date":"2024-05-20T06:19:13.728Z","url":"/2024/05/20/game-privacy-policy/","tags":[["game-privacy-policy","/tags/game-privacy-policy/"]],"categories":[[" ",""]],"content":"Game Privacy Policy Introduction This Privacy Policy outlines how we, as the developer and operator of the Game, collect, use, disclose, and otherwise process your personal information when you access and use our Game. We are committed to protecting your privacy and ensuring that your personal information is handled securely and responsibly. Collection of Personal Information When you use our Game, we may collect certain personal information about you, such as: Your username and password or other login credentialsYour game progress, scores, achievements, and other related gameplay dataDevice information, including IP address, device ID, and operating system detailsInformation about your interactions with the Game, such as your preferences, settings, and in-game behaviorPlease note that we do not intentionally collect any sensitive personal information about you, unless explicitly stated and with your consent. Use of Personal Information We use your personal information for the following purposes: To provide you with access to and functionality of the GameTo monitor and improve the Game’s performance and user experienceTo analyze gameplay data to develop and improve our servicesTo contact you regarding the Game, such as providing updates, announcements, or supportTo comply with applicable legal requirements and respond to legal inquiriesDisclosure of Personal Information We may share your personal information with third parties in the following limited circumstances: With our service providers and partners who assist us in operating and improving the GameIn response to legal requests, such as subpoenas or court ordersIf we believe it is necessary to protect our rights, property, or safety, or the rights, property, or safety of othersProtection of Personal Information We employ reasonable technical, administrative, and physical measures to safeguard the security and confidentiality of your personal information. However, please note that no transmission of data over the internet or any form of electronic storage is completely secure. While we strive to protect your personal information, we cannot guarantee its absolute security. Children’s Privacy Our Game is not intended for children under the age of 13. If you are a parent or guardian and believe that your child has provided us with personal information without your consent, please contact us immediately to request deletion of such information. Changes to Privacy Policy We may update this Privacy Policy from time to time to reflect changes in our practices or applicable laws. We will notify you of any significant changes by posting an updated version on our website or within the Game. It is your responsibility to review this Privacy Policy periodically for updates. Contact Information If you have any questions or concerns about this Privacy Policy or our handling of your personal information, please feel free to contact us at [insert contact information]. We will do our best to respond to your inquiries in a timely manner. Thank you for your trust and support in using our Game. We value your privacy and will continue to strive to protect it."},{"title":"彻底搞懂this指向","date":"2024-05-20T06:15:46.547Z","url":"/2024/05/20/this/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[[" ",""]],"content":"搞懂this指向 ps 为什么要搞懂this？因为JavaScript是面向对象编程，而this指向的就是对象 谁调用就指向谁例子： this最终指向的是调用它的对象，这里的函数test实际是被Window对象所点出来的。 效果是一样的，因为定义的函数也是window的一个属性。 在看另外个例子 这里this是指向对象test,按说法谁调用它就指向谁，那自然就是对象test。当然要在函数创建后这个说法才成立。 this永远指向的是最后调用它 这里指向的是window，因为this永远指向的是最后调用它的，也就是看它执行的时候是谁调用的。这个例子虽然函数fu是被test2所引用，但是在将fn赋值给变量call的时候并没有执行所以最终指向的是window 构造函数版this 这里之所以对象test可以点出函数Fn里面的user是因为new关键字可以改变this的指向，用了new关键字就是创建一个对象实例，我们这里用变量test创建了一个fn的实例（相当于复制了一份Fn到对象test里面），此时仅仅只是创建，并没有执行，而调用这个函数fn的是对象test，那么this指向的自然是对象test。 首先new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代。 当this碰到return时 如果函数返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。 自行改变this的指向开发环境的数据，测试环境没有开发环境的数据，只有改变环境才能更换数据。call,apply,bind 就是一般用来指定this的环境 call() 这里fn2指向的是window，通过call方法，第一个参数可以将fn2 window环境指向为你需要的环境中 也可以添加多个参数 apply()apply方法和call方法有些相似，它也可以改变this的指向，唯一不同的就是apply第二个参数只能是数组 ps 注意如果call和apply的第一个参数写的是null，那么this指向的是window对象 bind()bind方法和call、apply方法有些不同,bind方法是返回的是一个修改过后的函数。 这样会发现是没有执行的，因为bind返回的是一个修改后的函数，没有调用他 这样就可以调用，当然bind也是支持多个参数的，用法跟call一样"},{"title":"Fiddler替换域名","date":"2024-05-20T06:15:46.545Z","url":"/2024/05/20/fiddler/","tags":[["fiddler","/tags/fiddler/"]],"categories":[[" ",""]],"content":"通过fiddler替换域名 ps：提前安装好fiddler以及配置好 替换app里h5页面腾讯视频为例原型： 点击打开广告的h5页 通过fiddler可以替换域名，变为访问我们个人链接 1、打开主角Fiddler 2、找到我们要更改的url 3、点开AutoResponder 4、操作 全勾选上 最重要的操作： 点击Add rule 第一条输入框：regex:(?inx)^原先的域名* 第二条输入框：复制我们要更改的域名 右边点击保存 5、完成"},{"title":"从零开始建博客","date":"2024-05-20T06:15:46.544Z","url":"/2024/05/20/blog/","tags":[["GitHub","/tags/GitHub/"]],"categories":[[" ",""]],"content":"前言： 想弄个博客网站，就会联想到不得有台服务器吗？不得搞数据库吗？不得注册域名吗？没事，如果都没有，那照样是能搭建一个博客的。这里就要记录如何使用GitHub来建属于自己的博客。 安装环境Node下载地址： 可以安装 Stable 版本。安装完毕之后，确保环境变量配置好，能正常使用 npm 命令 HexoHexo是一个博客框架，Hexo 官方还提供了一个命令行工具，用于快速创建项目、页面、编译、部署 Hexo 博客，所以在这之前我们需要先安装 Hexo 的命令行工具。 安装命令npm install -g hexo-cli 安装完毕后可以输入hexo -v查看是否有版本号，确保环境变量配置好，能正常使用 hexo 命令 创建项目 我们使用 Hexo 的命令行创建一个项目，首先使用新建一个文件夹，改为你需要的名字（建议纯英文），打开命令行输入下面命令： 看到终端输出这样就完成了，文件夹下就会出现 Hexo 的初始化文件，包括 themes、scaffolds、source 等文件夹，这些内容暂且先不用管是做什么的，我们先知道有什么，然后一步步走下去看看都发生了什么变化 进入新生成的文件夹里面，然后调用 Hexo 的 generate 命令，将 Hexo 编译生成 HTML 代码，运行hexo generate命令后，可以看到输出结果里面包含了 js、css、font 等内容，并发现他们都处在了项目根目录下的 public 文件夹下面了 我们利用 Hexo 提供的 server 命令把博客在本地运行起来hexo server，运行之后命令行输出如下 点开本地 4000 端口上就可以查看博客站点了，如图所示： 到这里就已经把静态博客的架子已经搭建出来了 开始部署接下来我们把这个博客架子放到GitHub Pages上面看是否能成功，成功之后我们可以再进行博客样式 在部署之前我们需要先知道博客的部署地址，它需要对应 GitHub 的一个项目地址，首先在 GitHub 新建一个仓库，名称为 {username}.github.io，注意这个名比较特殊，必须要是 github.io 为后缀结尾的 建成后打开项目文件根目录下的 _config.yml 文件，找到 Deployment 这个地方，把刚才新建的 Repository 的地址贴过来，然后指定分支为 master 分支，最终修改为如下内容： 修改完后还需要额外安装一个支持 Git 的部署插件，名字叫做 hexo-deployer-git，有了它我们才可以顺利将其部署到 GitHub 上面，安装命令npm install hexo-deployer-git --save，安装完后就可以继续我们的部署 部署命令还是使用我们的hexo命令输出 运行到这步踩坑，没有在GitHub配置了ssh的话会让你输入，不然会一直运行失败，在GitHub配置好ssh就可以上传成功了。不会ssh配置可以点击教程成功后可以看到GitHub上传了什么 完成上面就可以实现自己的博客了，但是还没有配置好自己喜欢的主题和标题，hexo是支持修改站名和描述等等。修改根目录下的 _config.yml 文件，找到 Site 区域，这里面可以配置站点标题 title、副标题 subtitle 等内容、关键字 keywords 等内容，比如我的就修改为如下内容： 这样就完成了站点基本信息的配置，完成之后可以看到一些基本信息就修改过来了，页面效果如下： 更换主题GitHub上有很多主题都可以拉取下拉使用更改，目前 Hexo 里面应用最多的主题基本就是 Next 主题了，它支持的插件和功能也极为丰富，配置了这个主题，我们的博客可以支持更多的扩展功能，比如阅览进度条、中英文空格排版、图片懒加载等等。主题的 GitHub 地址是：，我们可以直接把 master 分支 Clone 下来。进入项目的根目录打开终端，运行下面命令 执行完毕之后 Next 主题的源码就会出现在项目的 themes/next 文件夹下。 然后我们需要修改下博客所用的主题名称，修改项目根目录下的 _config.yml 文件，找到 theme 字段，修改为 next 即可 然后本地重新开启服务，访问刷新下页面，就可以看到 next 主题就切换成功了，预览效果如下： 主题样式next提供很多样式，风格不变，但整个布局位置不太一样，通过修改scheme字段即可，注意是next文件下的_config.yml 刷新页面之后就会变成这种布局 头像avatar 这个就类似站点的头像，如果设置了这个，会在站点的作者信息旁边额外显示一个头像。红色箭头指向 把需要的图片放置themes/next/source/images/avatar.png 路径，然后在_config.yml文件下更改avatar配置，url位置上更改正确的路径 还有另外两个配置，rounded是配置是否为圆形，rotated鼠标移动过去是否可旋转 RSSRSS订阅是站点用来和其他站点之间共享内容的一种简易方式(也叫聚合内容)，即Really Simple Syndication(简易信息聚合)。通常被用于新闻和其他按顺序排列的网站。博客一般是需要 RSS 订阅的，如果要开启 RSS 订阅，这里需要安装一个插件，叫做 hexo-generator-feed，安装完成之后，站点会自动生成 RSS Feed 文件，安装命令npm install hexo-generator-feed --save，安装完成之后不需要其他的配置，以后每次编译生成站点的时候就会自动生成 RSS Feed 文件了 代码块博客写技术文必定出现的代码块，next也可以配置修改，修改 _config.yml 文件的 codeblock 区块如下 设置完如下： 阅读进度reading_process，阅读进度。大家可能注意到有些站点的最上侧会出现一个细细的进度条，代表页面加载进度和阅读进度，修改 _config.yml 如下： 设置完如下： 书签bookmark，书签，可以根据阅读历史记录，在下次打开页面的时候快速帮助我们定位到上次的位置，大家可以根据喜好开启和关闭 github_banner在一些技术博客上，大家可能注意到在页面的右上角有个 GitHub 图标，点击之后可以跳转到其源码页面，可以为 GitHub Repository 引流，permalink设为自己的GitHub链接，title是鼠标滑动过去显示的标题 评论由于 Hexo 的博客是静态博客，而且也没有连接数据库的功能，所以它的评论功能是不能自行集成的，但可以集成第三方的服务。Next 主题里面提供了多种评论插件的集成，有 changyan | disqus | disqusjs | facebook_comments_plugin | gitalk | livere | valine | vkontakte 这些。这里使用gitalk。它是利用 GitHub 的 Issue 来当评论，样式也比较不错。首先需要在 GitHub 上面注册一个 OAuth Application，链接为：，注册完毕之后拿到 Client ID、Client Secret 就可以了。 首先需要在 _config.yml 文件的 comments 区域配置使用 gitalk 然后找到 gitalk 配置，添加它的各项配置： 添加上面配置后刷新后就会出现这样的样式 无刷新加载可能大家听说过 Ajax，没听说过 pjax，这个技术实际上就是利用 Ajax 技术实现了局部页面刷新，既可以实现 URL 的更换，又可以做到无刷新加载。 要开启这个功能需要先将 pjax 功能开启，然后安装对应的 pjax 依赖库，首先修改 _config.yml 修改pjax: true 切换到 next 主题文件下，然后安装依赖库： 更多主题修改等配置可在 官网查看 文章一开始生成后细心的hexo已经给出这行命令了 hexo new hello-hexo运行这行命令就会出现在 source/_posts 文件夹下，是 MarkDown 格式。在文章开头通过如下格式添加必要信息： 开头下方撰写正文，MarkDown 格式书写即可。 这样在下次编译的时候就会自动识别标题、时间、类别等等，另外还有其他的一些参数设置，可以参考文档：。 标签页跟新建文章一样，在目录下输入hexo new page tags执行这个命令之后会自动帮我们生成一个 source/tags/index.md 文件，也是MarkDown格式的。我们可以在tags文件内我们可以自行添加一个 type 字段来指定页面的类型，如图所示： 在刚刚新建的文章文件中设置，如图所示： 设置完在主题的 _config.yml 文件将这个页面的链接添加到主菜单里面，修改 menu 把tags#去掉就可以达到打开标签页的效果，然后就可以到页面查看效果 搜索页添加搜索功能，需要先安装一个插件，叫做 hexo-generator-searchdb，命令如下： 然后在项目的 _config.yml 里面添加搜索设置如下： 然后在主题的 _config.yml 里面修改如下： 404页面页面都需要有个404状态页面，博客也不例外，直接在根目录 source 文件夹新建一个 404.md 文件即可，内容可以仿照如下： 新建完也要在主题_config.yml中打开404的# 部署脚本其实方便后面一行代码就可以直接完成博客更新来配置，在根目录下新建一个 deploy.sh 的脚本文件，内容如下： 这样我们在部署发布的时候只需要执行： 自定义域名GitHub还支持自定义域名的设置,在github项目 setting滑到看到page，设置完就可以看到这样提示 有一个值得注意的地方，如果配置了自定义域名，在目前的情况下，每次部署的时候这个自定义域名的设置是会被自动清除的。所以为了避免这个情况，我们需要在项目目录下面新建一个 CNAME 文件，路径为 source/CNAME，内容就是自定义域名。 比如我就在 source 目录下新建了一个 CNAME 文件，内容为 ##tips:## 配置自定义域名，需要自行购买有效的域名才可配置，否则会打不开"},{"title":"温故而知新（巩固js基础第一篇）","date":"2024-05-20T06:15:46.542Z","url":"/2024/05/20/base/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[[" ",""]],"content":"js为什么要单独开一个文件存放：js在浏览器作为单独文件有一个好处就是浏览器会下载它，然后保存到浏览器的缓存中。之后，其他页面想要相同的脚本就会从缓存中获取，而不是下载它。所以文件实际上只会下载一次。这可以节省流量，并使得页面（加载）更快。 代码结构代码结构的第一件事就是学会构建代码块。为什么？提高可读性 语句： 通常，每条语句独占一行，以提高代码的可读性 分号： 一个很少被重视的问题，因为在大多数情况下可以省略分号。但是“大多数情况”并不意味着“总是”！ 如果我们运行代码，只有第一个 alert 语句的内容被显示了出来，随后我们收到了一个错误！为什么？因为在js并不会在方括号 [...] 前添加一个隐式的分号。 第一个例子中的代码改为一条简单的语句，我们从引擎看到的是这样的： 怎么解决： 我们在第一个 alert(&quot;There will be an error&quot;); 语句末尾加上一个分号，就工作正常了 。 tips： 避免这种情况除了习惯的写完一条语句后在后面添加分号，还可以使用快捷格式化方式也可以达到语句后面自动加上分号。在vscode编译器的情况下要去除自动添加分号的话，安装 prettier 插件，在settings.json中添加 注释： 利用好注释可以省很多代码上的沟通和理解，但也要减少没必要的注释，栗子name // 姓名。 tips： 注释不能嵌套注释，否则会报错 现代模式（严格模式），”use strict”什么是现代模式（严格模式） js是不断进步的，一些新功能出来就有一些旧功能的抛弃，但为了兼容旧功能的代码就会保留着旧功能的使用。 “use strict” 这个指令看上去像一个字符串 &quot;use strict&quot; 或者 &#39;use strict&#39;。当它处于脚本文件的顶部时，那么整个脚本的文件都将进行 严格模式。 同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。 为什么要使用 为了避免写js语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 tips： &quot;use strict&quot; 指令只允许出现在脚本或函数的开头。否则严格模式可能无法启用。 变量变量是数据的“命名存储”。我们可以使用变量来保存商品、访客和其他信息。使用let var const声明，才能使用变量 注意事项： 1.大小写之分。2.允许非英文字母，但不推荐。3.不能用保留字来声明变量。4.未采用 use strict 下的赋值，在严格模式下直接赋值没有声明是会报错的，在普通模式下仍然可以正常工作，这是为了保持对旧脚本的兼容，所以要按严格模式变量都要进行声明。 数据类型在 js 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）。Number（数字）bigint（整数）String（字符串）Object（对象 特殊类型）Boolean（布尔值）Undefined（独立类型）Null（独立类型）Array（数组）Function（函数）Symbol（新增类型）typeof（运算符） 基本数据类型 number 用于任何类型的数字：整数或浮点数，在 ±(253-1) 范围内的整数。 bigint 用于任意长度的整数。 string 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。 boolean 用于 true 和 false。 null 用于未知的值 —— 只有一个 null 值的独立类型。 undefined 用于未定义的值 —— 只有一个 undefined 值的独立类型。 symbol 用于唯一的标识符。 object 用于更复杂的数据结构 其他数据类型-Array用于数组[]数据结构 Function用于函数 类型转换字符串（string）转换 数字型（number）转换在算术函数和表达式中，会自动进行 number 类型转换。 但 + 等于拼接， 栗子&#39;1&#39;+&#39;1&#39;会等于11，要手动转为数字才会相加Number()函数进行转换。如果该字符串不是一个有效的数字，转换的结果会是 NaN undefined 会变成 NaN null 会变成 0 true 和 false 会变成0 and 1 string 会变成去掉首尾空格后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 0。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 NaN。 基础运算符 运算元： 运算符应用的对象。比如说乘法运算 5 * 2，有两个运算元：左运算元 5 和右运算元 2。更多称为“参数”而不是“运算元”。 一元运算符： 如果一个运算符对应的只有一个运算元，那么它是 一元运算符。 二元运算符： 如果一个运算符拥有两个运算元，那么它是 二元运算符。 赋值运算符： = 也是一个运算符 链式运算符 可读性不高，所以不常使用 位运算符： 位运算符把运算元当做 32 位整数，并在它们的二进制表现形式上操作 。Web 开发中很少使用它们 逗号运算符： 是最少见最不常使用的运算符之一。有时候它会被用来写更简短的代码。可读性不高，所以不常使用 二元运算符支持以下数学运算： 加法 + 减法 - 乘法 * 除法 / 取余 %： 取余运算符是 %，尽管它看起来很像百分数，但实际并无关联。一个表达式的值除以另一个表达式的值，返回余数。公式：result = numberA % numberB 返回值：result，任何变量 参数：numberA，任何数值表达式。；numberB，任何数值表达式。 说明：取余（或余数）运算符用 number1 除以 number2 （把浮点数四舍五入为整数），然后只返回余数作为 result。 求幂 **：求幂运算 a ** b 是 a 乘以自身 b 次。 位运算符： 按位与 ( &amp; ) 按位或 ( | ) 按位异或 ( ^ ) 按位非 ( ~ ) 左移 ( &lt;&lt; ) 右移 ( &gt;&gt; ) 无符号右移 ( &gt;&gt;&gt; ) tips： 一元运算符优先级高于二元运算符，自增/自减只能应用于变量。运算符都有优先级。 值的比较 &lt; 小于 &gt; 大于 &gt;= 大于等于 &lt;= 小于等于 == 等于 === 全等 != 不等于 !== 不全等等于与全等区别：等于不进行数据类型判断，全等会进行判断。栗子： tips： undefined 不应该被与其他值进行比较"},{"title":"温故而知新（巩固js基础第二篇）","date":"2024-05-20T06:15:46.541Z","url":"/2024/05/20/base-two/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[[" ",""]],"content":"判断：if与三元在第一篇讲到了各种运算符，这里的三元运算符不同于算术运算上，所以没有写在同一篇。 if else语句常见的判断语句为if else，if(...) 语句计算括号里的条件表达式，如果计算结果是 true，就会执行对应的代码块。栗子： if 语句有时会包含一个可选的 “else” 块。如果判断条件不成立，就会执行它内部的代码。栗子： 还有时我们需要测试一个条件的几个变体。我们可以通过使用 else if 子句实现。 以上的代码块都是从上到下，严格按照js的同步进行，先判断if是否为true，如果不是才会进行下一个语句判断，依次往下。当然可以有更多的 else if 块。结尾的 else 是可选的。 类型转换if (…) 语句会计算圆括号内的表达式，并将计算结果转换为布尔型 数字 0、空字符串 &quot;&quot;、null、undefined 和 NaN 都会被转换成 false。因为它们被称为“假值（falsy）”值。 其他值被转换为 true，所以它们被称为“真值（truthy）”。三元运算符（条件运算符）‘?’我们需要根据一个条件去赋值一个变量就会想到使用刚刚才讲到的if else，但又感觉只是赋个值写代码块没必要。所谓的三元运算符让我们可以更简短地达到目的。之所以被称为“三元”是因为该运算符中有三个操作数。实际上它是 JavaScript 中唯一一个有这么多操作数的运算符。如何使用？栗子： 当如果三元运算符用来判断返回boolean的话，可以不需要用到三元运算符。栗子： 还可以嵌套多个三元运算符，但只可以返回一个取决于多个条件的值。栗子： 可能很难一下子看出发生了什么。就很影响了可读性。 第一个问号检查 age &lt; 3。 如果为真 — 返回 &#39;我不到三岁&#39;。否则，会继续执行冒号 &quot;:&quot; 后的表达式，检查 age &lt; 18。 如果为真 — 返回 &#39;我不到18岁&#39;。否则，会继续执行下一个冒号 &quot;:&quot; 后的表达式，检查 age &lt; 100。 如果为真 — 返回 &#39;我不到100岁&#39;。否则，会继续执行最后一个冒号 &quot;:&quot; 后面的表达式，返回 &#39;剩下就是我的岁数&#39;。有时候使用三元运算符是为了简便，但多了话就会很复杂，不建议这样使用三元运算符。 tips： 建议每次使用 if 语句都用大括号 &#123;&#125; 来包装代码块，即使只有一条语句。这样可以提高代码可读性。 逻辑运算符js中有三个常用的逻辑运算符：||（或），&amp;&amp;（与），!（非）。还有新增的非空运算符：?? 虽然它们被称为“逻辑”运算符，但这些运算符却可以被应用于任意类型的值，而不仅仅是布尔值。它们的结果也同样可以是任意类型。 || （或）一个或运算 || 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。下面栗子将解释这段话。 两个竖线符号表示||“或”运算符： 用作于判断使用的话，有四种逻辑情况 用于表达式或者变量列表使用的话 前面变量的值都为假，结果就是 &quot;Anonymous&quot;。 &amp;&amp;（与）与运算返回第一个假值，如果没有假值就返回最后一个值。上面的规则和或运算很像。区别就是与运算返回第一个假值，而或运算返回第一个真值。 两个 &amp; 符号表示 &amp;&amp; 与运算符： 跟或运算符不一样的是，当值都为真值时才会返回true，这里也举四个栗子跟或运算符做比较： !（非）感叹符号 ! 表示布尔非运算符。 在第一篇的不等于（!==）使用过 逻辑非运算符接受一个参数，并按如下运作： 将操作数转化为布尔类型：true/false。 返回相反的值。有时候我们会看到有两个!!是用来将某个值转化为布尔类型??（非空运算符）与 （||） 或运算符一样,唯一不一样的仅当值为 null 或 undefined 时才当为假值，其余都为真。 在非空运算符基础上还能简写??= 空赋值运算符： 拆分为： 但是出于安全原因，JavaScript 禁止将 ?? 运算符与 &amp;&amp; 和 || 运算符一起使用，除非使用括号明确指定了优先级。 tips： 优先级 ! &gt; &amp;&amp; &gt; || ?? 运算符的优先级非常低，仅略高于 ? 和 =，因此在表达式中使用它时请考虑添加括号。 如果没有明确添加括号，不能将其与 || 或 &amp;&amp; 一起使用。for和while 循环 是一种重复运行同一代码的方法。 while 循环 当 condition 为真时，执行循环体的 code。 例如，以下将循环输出当 i &lt; 3 时的 i 值： 循环体的单次执行叫作 一次迭代。上面示例中的循环进行了三次迭代。 如果上述示例中没有 i++，那么循环（理论上）会永远重复执行下去，称为“死循环”。浏览器提供了阻止这种循环的方法，我们可以通过终止进程，来停掉服务器端的 JavaScript。 当循环体只有一条语句，则可以省略大括号 &#123;…&#125;： for循环for 循环更加复杂，但它是最常使用的循环形式。 for 循环看起来就像这样： 栗子： 分析 for 循环：begin | i = 0 | 进入循环时执行一次。 || ——— | ———- | ————————— || condition | i &lt; 3 | 在每次循环迭代之前检查，如果为 false，停止循环。 || body（循环体） | alert(i) | 条件为真时，重复运行。 || step | i++ | 在每次循环体迭代后执行。 for循环算法的工作原理如下： 把工作原理使用到栗子上： 省略语句for条件中需要三个条件，这些如果不需要的话是可以省略掉的 省略了begin参数，但 ; 是一定要存在的。我们也可以移除 step 语句段： 这样写法跟while (i &lt; 3) 等价。 for 的两个 ; 必须存在，否则会出现语法错误。 for还有语句： break 强制退出循环 continue break 的“轻量版”。它不会停掉整个循环。而是停止当前这一次迭代，并强制启动新一轮循环（如果条件允许的话）。 "},{"title":"vue3配置404notFound","date":"2021-12-03T08:24:27.000Z","url":"/2021/12/03/vue3config404notFound/","tags":[["vue3","/tags/vue3/"]],"categories":[[" ",""]],"content":"vue3配置404notFound常规参数只匹配 url 片段之间的字符，用 / 分隔。其实在router官网中有写可用正则来自定义，官网是这样写： 在一般设置404页面路由的时候我们便是： 但是使用的是vue3的话,会遇到这样的一个报错: Catch all routes (“*”) must now be defined using a param with a custom regexp. 这个报错翻译过来就是捕获所有路由（“*”）现在必须使用带有自定义regexp的参数定义"},{"title":"provide/inject调用hook","date":"2021-01-10T02:30:07.000Z","url":"/2021/01/10/provide-or-inject/","tags":[["vue3","/tags/vue3/"]],"categories":[[" ",""]],"content":"provide/inject调用hook ps：hook函数每一次调用都会重新执行，导致有些数据子组件要用又重新执行生命周期一遍 用到的provide/inject、symbol来封装可传递性的hook方法。这里用到是因为symbol类型是唯一、不可变的标识符 useProviderprovide是一个对象，或者是一个返回对象的函数，需要属性名以及属性值。 useInjectorinject属性值是一个字符串数组，或者是一个对象。 只要判断唯一标识定义的token，就可以拿到该有的属性值返回。封装就是为了复用、便利在传参是否没有provide的情况下可以自助创建。 "},{"title":"快速上手搭建简易版脚手架","date":"2020-06-03T02:41:27.000Z","url":"/2020/06/03/simple-npm/","tags":[["Npm","/tags/Npm/"]],"categories":[[" ",""]],"content":"前言： 使用过那么多脚手架，自己也实现一个简易版的 了解美化脚手架依赖包：1、commander这是用来编写指令和处理命令行的，具体用法如下： 回忆一下，我们曾用过的 vue init 的命令就是这样声明的。 2、inquirer这是个强大的交互式命令行工具，具体用法如下： 3、chalk 这是用来修改控制台输出内容样式的，比如颜色啊，具体用法如下： 4、ora这是一个好看的加载，就是你下载的时候会有个转圈圈的那种效果，用法如下： 5、download-git-repo看名字很明显了，这是用来下载远程模板的，支持 GitHub、 GitLab 和 Bitbucket 等，用法如下： 其中 repository 是远程仓库地址；destination 是存放下载的文件路径，也可以直接写文件名，默认就是当前目录；options 是一些选项，比如 { clone：boolean } 表示用 http download 还是 git clone 的形式下载。 开始：搭建准备工作新建文件夹、在目录下执行npm init 命令 会生成一个生成 package.json 文件，在 package.json 里面写入以下依赖并执行 npm install 安装，如下： 新建一个 bin 文件夹，并在 bin 目录下新建一个无后缀名的 xr 文件，并写上： 这个文件就是我们整个脚手架的入口文件，我们用 node ./bin/xr 运行一下，就能在控制台打印出 hello这里要注意开头的 #!/usr/bin/env node这个语句必须加上，主要是为了让系统看到这一行的时候，会沿着该路径去查找 node 并执行，主要是为了兼容 Mac ，确保可执行。 bin 目录初始化 发布到 npm既然以上命令都执行成功了，那接下来我们就把它发布到 npm 上。 删除 test 文件夹，它就本地测试用的 在根目录下新建 README.md 文件，使用说明 在根目录下新建 .npmignore 文件，并写入 /node_modules ，意思就是发布的时候忽略 node_modules 文件夹， 去 npm 官网注册个账号 现在让我们回到项目根目录，执行 npm login 登入 npm 账号，再执行 npm publish 发布 发布完成后使用一下，是否能正常运行。这里我们记得先用 npm unlink 解绑一下命令，不然会相互影响。下面我们打开终端，输入 npm i xr-cli -g 全局安装一下脚手架，然后执行 xr "},{"title":"404 Not Found","date":"2021-09-20T02:41:27.000Z","url":"/404.html","categories":[[" ",""]],"content":" 对不起，您所访问的页面不存在或者已删除。 您可以点击此处返回首页。 白墙 "},{"title":"输入文章标题搜索","date":"2024-05-20T06:15:46.548Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"标签","date":"2021-09-20T11:30:14.000Z","url":"/tags/index.html","categories":[[" ",""]]}]